---
title: "Self-Evaluation Project"
author: "Andy"
date: "3/13/2022"
output:
  html_document:
    toc: true
    toc_float:
      smooth_scroll: false
---

<br>  


```{r, results='hide', message=FALSE}
library(lubridate)
library(gridExtra)
library(tidyverse)
library(margins)
library(psych)
library(grid)
```



```{r, echo=FALSE}

all_dat = read.csv('/Volumes/Programming/Spring 2022/project/all_dat.csv')
# all_dat = read.csv('D:/Spring 2022/Project/all_dat.csv')
morning_rt = read.csv('/Volumes/Programming/Spring 2022/Project/morning_routine.csv')


colnames(all_dat) <- c('X', 'Name','Finished','Multiple','Phone_pickups',
                       'Screen_time','Created','Date','Drink','Key_words',
                       'Meditation','Mentality','Satisfaction',
                       'Reading','Productivity','Rise_time','Run','Social',
                       'Tech','Total','Total_todo','Work_done')



# Remove unnecessary columns & Modify some columns
all_dat <- all_dat %>%
  dplyr::select(Date, everything(), Finished, Total_todo,-X,-Name,-Created, - Work_done) %>%
  dplyr::mutate(work_finished = round(Finished/Total_todo,4),
         Drink = lag(Drink),
         Total = Total*100)%>%
  tibble()

# Correct the date format for earlier Dates
all_dat$Date[1:114] = format(mdy(all_dat$Date[1:114]),"%m/%d/%Y")


# Same for morning routine #new
morning_rt <- morning_rt %>%
  dplyr::mutate(Date = strptime(as.character(morning_rt$Date), "%m/%d/%Y"),
         Date = format(Date, "%m/%d/%Y"),
         morning_phone = rise_time_check, # modify column name 
         night_phone = before_sleep_check) %>%
  dplyr::select(Date, everything(), -c(X, level_0, index, 
                                rise_time_check, before_sleep_check)) %>%
  tibble()

```



```{r, echo=FALSE}
# Break dates
  # Fall, Thanksgiving, Christmas, Spring, Summer, etc.
date_breaks <- as.character(format(c(
seq(as.Date('11/25/2020', format = "%m/%d/%Y"), by = "day", length.out = 5),
seq(as.Date('12/17/2020', format = "%m/%d/%Y"), by = "day", length.out = 46),
seq(as.Date('03/23/2021', format = "%m/%d/%Y"), by = "day", length.out = 6),
seq(as.Date('04/23/2021', format = "%m/%d/%Y"), by = "day", length.out = 6),
seq(as.Date('05/19/2021', format = "%m/%d/%Y"), by = "day", length.out = 104),
seq(as.Date('10/11/2021', format = "%m/%d/%Y"), by = "day", length.out = 2),
seq(as.Date('12/21/2021', format = "%m/%d/%Y"), by = "day", length.out = 37),
seq(as.Date('03/14/2022', format = "%m/%d/%Y"), by = "day", length.out = 7)),
"%m/%d/%Y"))

# Semester Quarters
# 1st quarter of the semester
first_q <- c(as.character(format(c(
  seq(as.Date('09/01', format = "%m/%d"), by = "day", length.out = 27),
  seq(as.Date('02/01', format = "%m/%d"), by = "day", length.out = 27)),"%m/%d")))

# 2nd quarter of the semester
second_q <- c(as.character(format(c(
  seq(as.Date('09/28', format = "%m/%d"), by = "day", length.out = 27),
  seq(as.Date('02/28', format = "%m/%d"), by = "day", length.out = 27)),"%m/%d")))

# 3rd quarter of the semester
third_q <- c(as.character(format(c(
  seq(as.Date('10/25', format = "%m/%d"), by = "day", length.out = 27),
  seq(as.Date('03/27', format = "%m/%d"), by = "day", length.out = 27)),"%m/%d")))

# 4th quarter of the semester
fourth_q <- c(as.character(format(c(
  seq(as.Date('11/21', format = "%m/%d"), by = "day", length.out = 26),
  seq(as.Date('04/23', format = "%m/%d"), by = "day", length.out = 27)),"%m/%d")))

# Create School variable
all_dat <- all_dat %>%
  dplyr::mutate(
    School = ifelse(
      format(as.Date(strptime(all_dat$Date, "%m/%d/%Y")), "%m/%d") %in% first_q, "1st", FALSE),
    School = ifelse(
      format(as.Date(strptime(all_dat$Date, "%m/%d/%Y")), "%m/%d") %in% second_q, "2nd", School),
    School = ifelse(
      format(as.Date(strptime(all_dat$Date, "%m/%d/%Y")), "%m/%d") %in% third_q, "3rd", School),
    School = ifelse(format(as.Date(strptime(all_dat$Date, "%m/%d/%Y")), "%m/%d") %in% fourth_q, "4th", School),
    School = ifelse(Date %in% date_breaks, "Break", School),
    School = ifelse(Date == '08/30/2021', "1st", School),
    School = ifelse(Date == '08/31/2021', "1st", School),
    School = ifelse(Date %in% c('12/17/2021','12/18/2021','12/19/2021','12/20/2021'), "4th", School),
    School = ifelse(Date %in% c("01/27/2022","01/28/2022"), "1st",School),
    Weekdays = weekdays(as.Date(Date,'%m/%d/%Y')),
    date_sep = Date
  ) %>%
  separate(date_sep, into = c("month", "day", "year"), sep="/") # Create year, month, day variables

# merge morning_rt with all_dat
all_morning_rt <- merge(morning_rt, all_dat,by="Date", all.x=T) %>%
  dplyr::mutate(Date = mdy(Date),
         work_finished_mr_exc = 
           round((Finished-total_checked)/(Total_todo-6),4)) %>%
            # work_finished_mr_exc: this variable excludes morning routine 
            #         tasks for more accurate statistical analysis. 
  
  dplyr::select(-c(rise_time_min)) %>% # redundant
  dplyr::filter(work_finished_mr_exc <= 1 & work_finished_mr_exc >0) %>%
  arrange(desc(Date))


```

  
<br>  

# **Main Variables: Descriptive Statistics**

---

<br>  


```{r, echo = FALSE, eval = TRUE, fig.width = 7, fig.height = 7, warning = FALSE, fig.align='center'}

p1 <- ggplot(data = all_dat, alpha=.5) + 
  geom_density( aes(Total), color = 'red')

p2 <- ggplot(data = all_dat) +
  geom_density( aes(Multiple), color = 'blue')

p3 <- ggplot(data = all_dat, alpha=.5)+
  geom_density( aes(Reading), color = 'purple')

p4 <-ggplot(data = all_dat, alpha=.5)+
  geom_density(aes(Meditation), color = 'black')

p5 <- ggplot(data = all_dat, alpha=.5)+
  geom_density(aes(Phone_pickups), color = 'green')

p6 <- ggplot(data = all_dat, alpha=.5)+
  geom_density(aes(Screen_time), color = 'orange')

p7 <- ggplot(data = all_dat, alpha=.5)+
  geom_density(aes(Rise_time), color = 'skyblue')

p8 <- ggplot(data = all_dat, alpha=.5)+
  geom_density(aes(Drink), color = 'darkgreen')

p9 <- ggplot(data = all_dat, alpha=.5)+
  geom_density(aes(work_finished), color = 'darkgreen')

p10 <- ggplot(data = all_dat, alpha=.5)+
  geom_density(aes(Total_todo), color = 'darkgreen')
  
grid.arrange(p1, p2, p3,p4,p5,p6,p7,p8,p9,p10, nrow = 5,
             top = textGrob("Density Distribution for the Main Variables\n",gp=gpar(fontsize=16,font=1)))

```
<br>  

## Main Varibles Descriptions

* <font size="3">**Reading**: reading duration in minutes</font>
* <font size="3">**Meditation**: meditation duration in minutes</font>
* <font size="3">**Phone_pickups**: number of times I picked up my phone</font>
* <font size="3">**Screen_time**: duration of spent time on my phone in minutes</font>
* <font size="3">**Rise_time**: the variation in minutes from the intended rise time
    + 0: Woke up on time
    + -n: Woke up n minutes earlier than intended
    + +n: Woke up n minutes later than intended</font>
* <font size="3">**Drink**: Whether or not I drank the day before (Boolean)</font>
* <font size="3">**Work_finished**: Finished_tasks / Total_tasks </font>
* <font size="3">**Multiple**: Subjective grade given each day
    + Considered factors: Mentality, Satisfaction, Productivity, Social interaction, and Tech consumption</font>
* <font size="3">**Total**: The sum of the percentages calculated of above variables</font>

<br>  
<br>  

## Main Variables Correlations

<font size="4">To find the relationships between these variables and how they affect my lifestyle, we will first observe the relationships within variables</font>

* <font size="3">Use **pairs.panels function** in psych module
  + **The diagonal histograms** demonstrates the distribution of each variable 
  + **The bottom left triangle** represents a scatter plot with the best fit line
  + **The top right triangle** represents a correlation coefficient for each pair, which ranges from -1 to 1
      - If the coefficient is close to 1, it means that the pair holds a positive relationship and a negative relationship for -1. 
  + Correlation Coefficient Formula:</font>
$$r = \dfrac{\sum(x_i-\bar{x})(y_i-\bar{y})}{\sqrt{\sum(x_i-\bar{x})^2\sum(y_i-\bar{y})^2}}$$

<br>  


```{r, echo = TRUE, eval = TRUE, fig.width = 9, fig.height = 5, fig.asp = .75,  warning = FALSE}
correlation_plot <- all_dat %>%
  dplyr::select(c(Screen_time, Meditation, Multiple, Rise_time, 
           Reading,Phone_pickups, work_finished, Total))

pairs.panels(correlation_plot, lm = TRUE)
```

<br>  



## School Variable
```{r, echo = TRUE, eval = TRUE, fig.width = 7, fig.height = 5, warning = FALSE}
ggplot(data = all_dat, aes(x = work_finished,
                           color = School))+
  geom_density()+
  labs(title = "Density Plot of Work Finished% for different School periods",
       x = "Work Finished (%)")+
  theme(plot.title = element_text(face = "bold")) +
  scale_color_discrete(name = "School Qtrs")
```
<br>  
<br>  
<br>  


## Weekday Variable
```{r, echo = TRUE, eval = TRUE,   warning = FALSE}

all_dat$Weekdays <- factor(all_dat$Weekdays,levels = c("Monday", "Tuesday", "Wednesday", "Thursday","Friday","Saturday","Sunday"))

ggplot(data = all_dat)+
  geom_boxplot(aes(x = Weekdays,
                   y = work_finished, color = Weekdays))+
  theme(legend.position = "None")+
  labs(title = "Work finished % by week days",
       subtitle = "Data: all_dat (500+ observations)",
       x = "", y = "Work Finished (%)")+
  theme(plot.title = element_text(face = "bold"))
```
<br>  
<br>  


## Time Trend (Total %)
```{r, echo = TRUE, eval = TRUE, fig.width = 7, fig.height = 5, warning = FALSE, message=FALSE}
all_dat_month <- all_dat %>%
  dplyr::group_by(year, month) %>%
  dplyr::summarise(Total = mean(Total),
            Rise_time = mean(Rise_time)) %>%
  dplyr::mutate(Date = make_date(year, month)) %>%
  arrange(Date)
  
  
ggplot(all_dat_month)+
  geom_line(aes(x=Date, y=Total))+
  labs(title = "Trend of Total%",
              subtitle = "Grouped by Month Average")+
  theme(plot.title = element_text(face = "bold")) +
  scale_x_continuous(breaks = ymd("2020-09-01", "2021-01-01","2021-04-01", "2021-07-01", "2021-10-01","2022-01-01", "2022-04-01"),
                     labels=c("09/20", "01/21", "04/21", "07/21", 
                                "10/21", "01/22","04/22"))
  

```

<br>  
<br>  


## Time Trend (Total % - Rise time)
```{r, echo = TRUE, eval = TRUE, fig.width = 7, fig.height = 5, warning = FALSE, message=FALSE}
ggplot(all_dat_month)+
  geom_line(aes(x=Date, y=Total-Rise_time))+
  labs(title = "Trend of Total% - Rise time",
              subtitle = "Larger positive differnce indicates higher productivity")+
  theme(plot.title = element_text(face = "bold")) +
  scale_x_continuous(breaks = ymd("2020-09-01", "2021-01-01", "2021-06-01",
                                "2022-01-01"))
  
```
<br>  

* <font size="3">Note for Rise time: 
    + 0: Woke up on intended time
    + Positive value: Later than intended
    + Negative value: Earlier than intended</font>
<br>  

<br>  

<br>  

<br>  



# **Morning Routine Varables: Descriptive Statistics**

---

<br>  

$$"The\ notion\ that\ once\ you\ set\ accomplishment\ in\ motion,\\ you\ can\ keep\ it\ in\ motion\ with\ much\ less\ effort\ than\\ if\ you\ were\ trying\ to\ accomplish\ something\ from\ a\ standing\ start."\\ -Jim\ Kwik$$
<br>  
<br>  


```{r, echo = FALSE, eval = TRUE, fig.width = 8, fig.height = 9, warning = FALSE, fig.align='center'}
# Total_checked: the number of morning routine tasks completed
mr_p1 <- ggplot(data = all_morning_rt) +
  geom_bar(aes(x = total_checked), fill = "orange",
           alpha = .8)+
  theme(legend.position = "None")

# Meditation_check: Meditation task completion (Boolean value)
mr_p2 <- ggplot(data = all_morning_rt) +
  geom_bar(aes(x = meditation_check, fill = meditation_check),
           alpha = .8)+
  theme(legend.position = "None")

# Reading_check: Reading task completion (Boolean value)
mr_p3 <- ggplot(data = all_morning_rt) +
  geom_bar(aes(x = reading_check, fill = reading_check),
           alpha = .8)+
  theme(legend.position = "None")

# morning_thoughts_check: Morning journal task completion (Boolean value)
mr_p4 <- ggplot(data = all_morning_rt) +
  geom_bar(aes(x = morning_thoughts_check, fill = morning_thoughts_check),
           alpha = .8)+
  theme(legend.position = "None")

# push_up_check: Push up task completion (Boolean value)
mr_p5 <- ggplot(data = all_morning_rt) +
  geom_bar(aes(x = push_up_check, fill = push_up_check),
           alpha = .8)+
  theme(legend.position = "None")

# Morning_phone: Did not touch my phone for the first hour of the day (Boolean value)
mr_p6 <- ggplot(data = all_morning_rt) +
  geom_bar(aes(x = morning_phone, fill = morning_phone),
           alpha = .8)+
  theme(legend.position = "None")

# Night_phone: Did not touch my phone for the last hour of the day (Boolean value)
mr_p7 <- ggplot(data = all_morning_rt) +
  geom_bar(aes(x = night_phone, fill = night_phone),
           alpha = .8, position = "dodge")+
  theme(legend.position = "None")

grid.arrange(mr_p2, mr_p3,mr_p4,mr_p5,mr_p6,mr_p7,mr_p1, nrow = 4,
             top = textGrob("Distribution for the Morning Routine Variables\n",gp=gpar(fontsize=16,font=1)))

```
<br>  

<br>  


## Morning Routine Descriptions
Note that they are all discrete/ categorical variables
<br>  

* <font size="3">**Total_checked**: The number of morning routine tasks completed</font>
* <font size="3">**Meditation_check**: Meditation task completion (Boolean value)</font>
* <font size="3">**Reading_check**: Reading task completion (Boolean value)</font>
* <font size="3">**morning_thoughts_check**: Morning journal task completion (Boolean value)</font>
* <font size="3">**Push_up_check**: Push up task completion (Boolean value)</font>
* <font size="3">**Morning_phone**: Did not touch my phone for the first hour of the day (Boolean value)</font>
* <font size="3">**Night_phone**: Did not touch my phone for the last hour of the day (Boolean value)</font>


<br>  
<br>  



## Test how Total_checked variable affects the outcome of the day
* <font size = "4">The morning routine tasks:
  + Not touching my phone for at least 30 minutes the night before
  + Not touching my phone for an hour after I wake up
  + Exercise (Push up)
  + Meditation
  + Reading
  + Morning journal </font>
  
```{r, collapse=TRUE, figures-side, fig.asp = .75,  warning = FALSE}

# see how number of morning routine checks affects the Total %
ggplot(dplyr::filter(all_morning_rt, total_checked != 0)) + 
  geom_density(aes(Total))+
  facet_wrap(~total_checked)+
  labs(title = "Morning Routine checked & \nTotal %")

# see how number of morning routine checks affects the total todo lists checked
ggplot(dplyr::filter(all_morning_rt, total_checked != 0)) + 
  geom_density(aes(work_finished_mr_exc))+
  facet_wrap(~total_checked)+
  labs(title = "Morning Routine checked & \n todo lists finished(excluding morning routine tasks)")
```


<br>  

<br>  

<br>  



# **Main Variables: Linear Regressions**

---

## Simple Linear Regression
* <font size = "3">Set:
  + x = Explanatory Variable
  + y = Dependent Variable
  + $\alpha$ = y-intercept
  + $\beta$ = slope </font>

* <font size = "3">lm() function:Fitting Linear Models
  1. Finds fitted line($\alpha$ & $\beta$) by using the least-square method
      - **Least-square**: by summing up the residual squares for different curves, it finds the "least squared" curve that best fit the data. 
  2. Outputs $R^2$, p-value and other meaningful calculations
      - $R^2$: It demonstrates how accurate the fitted line is to the data
      - Formula: $R^2 =1-\dfrac{Var(fit)}{Var(mean)}$ or $1-\dfrac{RSS}{TSS}$
      - Ex: If we get.8, it means that $x$ explains 60% of the variation in $y$</font>

<br>  

```{r, echo = TRUE, eval = TRUE, fig.width = 6, fig.height = 5, warning = FALSE, message=FALSE}
model <- lm(work_finished ~ Meditation, data = all_morning_rt)
summary(model)
ggplot(all_dat,aes(x=Meditation, y=work_finished))+
  geom_smooth(method = "lm")+
  geom_point()+
  labs(title = "Linear Regression",
       subtitle = "y = Total to-do lists finished (%) \nx = Meditation in minutes",
       y = "Total to-do lists finished (%)", x = "Meditation in minutes")+
  theme(plot.title = element_text(face = "bold"))+
  theme_minimal()
```
  
  
```{r, echo = TRUE, eval = TRUE, fig.width = 6, fig.height = 5, warning = FALSE, message=FALSE}
model <- lm(Phone_pickups ~ Rise_time, data = all_morning_rt)
summary(model)
ggplot(all_dat,aes(x=Rise_time, y=Phone_pickups))+
  geom_smooth(method = "lm")+
  geom_point()+
  labs(title = "Linear Regression",
       subtitle = "y = The number of Phone pickups\nx = Rise time",
       y = "Number of Phone pickups\n", x = "\nRise time")+
  theme(plot.title = element_text(face = "bold"))+
  theme_minimal()
```

<br>  
<br>  
<br>  

## Multiple regressions
* <font size = "3">Set:
  + y = Dependent Variable
  + $x_1,...x_n$ = n independent/explanatory variables
  + $\alpha$ = Constant or intercept
  + $\beta$ = weights for each $x_1,...x_n$ </font>
  
  
```{r, echo = TRUE, eval = TRUE, fig.width = 6, fig.height = 5, warning = FALSE, message=FALSE}
model <- lm(work_finished ~ Phone_pickups + Screen_time, data = all_morning_rt)
summary(model)


```


## Logistic Regression

<br>  


### Single Logistic Regression
```{r, message=FALSE, warning=FALSE}
model_logit <- glm(work_finished_mr_exc ~ night_phone,
                   data = all_morning_rt, family = binomial(link = "logit"))
m = margins(model_logit) 
ame_result = summary(m) 
ame_result
```
<br>  

### How to interpret the Average Marginal Effect(AME) values
* <font size = "3"> Interpret them as percentage points rather than percentage
  + work_finished  .1911 : Indicates that if I do not touch my phone the night before, I am 19.06 percentage point more likely to get more tasks done. </font>
<br>  

```{r, fig.align='center'}
ggplot(data = ame_result) +
  geom_point(aes(factor , AME)) +
  geom_errorbar(aes(x = factor, ymin = lower, ymax = upper),
  width = .5) + geom_hline ( yintercept = 0) +
  theme_minimal ( ) +
  theme(axis.text.x = element_text(angle = 90))
```



<br>  


### Meditation with all_dat
```{r, echo=FALSE}

# Click below to see more about lm() summary function
# https://www.learnbymarketing.com/tutorials/explaining-the-lm-summary-in-r/#:~:text=Summary%20in%20R-,Explaining%20the%20lm()%20Summary%20in%20R,the%20error%20of%20the%20model.

meditation_all <- lm(Meditation ~ Multiple+ Phone_pickups+ Screen_time+ Drink+
                       Reading+ Rise_time+ Total_todo + Total + work_finished, 
                     data = all_dat)
summary(meditation_all)

```


<br>  

### Multiple with all_dat
* Multiple data length: 450 + 
```{r}
# Multiple data all
multiple_all <- lm(Multiple ~ Phone_pickups+ Screen_time+ Drink+ Meditation+
                     Reading+ Rise_time+ Run + Total_todo + Total , 
                   data = all_dat)
summary(multiple_all)
```

  
<br>  


## Linear Regression Summary for Work_done (all_dat)

```{r}
#################### Linear Regression Work_done (all_dat) #####################

# Work done 
work_finished_all <- lm(work_finished ~ Multiple + Phone_pickups + Screen_time + 
                          Drink + Meditation + Reading + Rise_time + Run + 
                          Total_todo,
                        data = all_dat)
summary(work_finished_all)
```
  
<br>  


## Actual vs Prediction Visualization for Work_done (all_dat)

```{r, warning=FALSE}
all_dat$pred_work_finished <- predict(work_finished_all, newdata = all_dat)

# Explanatory variable: work_finished
ggplot(data = all_dat, aes(x = pred_work_finished, y = work_finished)) +
  geom_point(alpha = 0.5, color = "darkgray") +
  geom_smooth(color = "darkblue") +
  geom_line(aes(x = work_finished,
                y = work_finished),   # Plotting the line, y = x
            color = "red", linetype = 2) +
  coord_cartesian( xlim = c(0, 1),
                   ylim = c(0, 1) )  # Limits the range of the

```
  
<br>  


## Actual vs Prediction Residual Visualization for Work_done (all_dat)

```{r, warning=FALSE}
# graph for legibility# Plot of residual error as a function of prediction
ggplot(data = all_dat, aes(x = pred_work_finished,
                           y = pred_work_finished - work_finished)) +
  geom_point(alpha = 0.2, color = "darkgray") +
  geom_smooth(color = "darkblue") +
  geom_line(aes(x = pred_work_finished,
                y = 0),   # Plotting the line, y = 0
            color = "red", linetype = 2) +
  ylab("residual error (prediction - actual)")

```

<br>  


## Testing Normality

```{r}
library(dplyr)
set.seed(1234)
dplyr::sample_n(all_dat, 10)

# The central limit theorem tells us that no matter what distribution things 
# have, the sampling distribution tends to be normal if the sample is large 
# enough (n > 30).

# The R function shapiro.test() can be used to perform the Shapiro-Wilk test 
# of normality for one variable (univariate):

shapiro.test(all_dat$Total)

```
<br>  

  
  
##  Determining Distributions
* Multiple(fit.normal)

```{r}

library(fitdistrplus)
library(logspline)

# The kurtosis and squared skewness of your sample is plotted as a blue point 
# named "Observation".
descdist(all_dat$Multiple, discrete = FALSE)
descdist(all_dat$Screen_time, discrete = FALSE)

wf <- c(na.omit(all_dat$work_finished))
descdist(wf, discrete = FALSE)

#fit.beta <- fitdist(wf, 'beta', method = "mme") 
  # method = "mme": Moment matching estimation consists in equalizing theoretical
  #                 and empirical moments. 
#fit.gamma <- fitdist(all_dat$Screen_time, "gamma")
fit.normal <- fitdist(all_dat$Multiple, "norm")
#plot(fit.beta)
#plot(fit.gamma)
plot(fit.normal)
```

